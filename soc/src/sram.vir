ext mod SRam {
    incoming clock : Clock;
    incoming addr : Word[14];
    incoming write_enable : Bit;
    incoming write_mask : Word[4];
    incoming data_inp : Word[16];
    outgoing data_out : Word[16];
}

union type RamState {
    idle();
    read();
    write();
    wait();
}

mod Ram {
    incoming clock : Clock;
    incoming reset : Bit;
    incoming addr : Word[14];
    incoming write_enable : Bit;
    incoming write_mask : Word[4];
    incoming data_inp : Word[32];
    outgoing data_out : Word[32];
    outgoing ready : Bit;

/*
    reg state : RamState on clock;
    state <=
        if reset {
            @idle()
        } else {
            match state {
                @idle() =>
                    if read_enable {
                        @read()
                    } else {
                        @write()
                    };
                @read() => @wait();
                @write() => @wait();
                @wait() => 
                    if read_enable {
                        @read()
                    } else if write_enable {
                        @write()
                    } else {
                        @idle()
                    };

            }
        };
        */

    reg is_waiting : Bit on clock;
    is_waiting <= if reset { false } else { is_waiting->not() };

    mod sram_hi of SRam;
    mod sram_lo of SRam;
    sram_hi.clock := clock;
    sram_lo.clock := clock;

    sram_hi.write_mask := write_mask;
    sram_lo.write_mask := write_mask;

    sram_hi.write_enable := write_enable;
    sram_lo.write_enable := write_enable;

    sram_hi.addr := addr;
    sram_lo.addr := addr;

    sram_hi.data_inp := data_inp[32..16];
    sram_lo.data_inp := data_inp[16..0];

    data_out := word(sram_hi.data_out, sram_lo.data_out);
    ready := is_waiting->not();
}
